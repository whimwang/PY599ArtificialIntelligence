# -*- coding: utf-8 -*-
"""Road Trip Opitimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/129MrK97ATF4wOl4Wbdh1xPfDo1DiFuh_
"""

import json, urllib
orig_address="Seattle,WA"
dest_address="Victoria,BC"
url="https://maps.googleapis.com/maps/api/distancematrix/json?origins={0}&destinations={1}&mode=driving&language=fr-FR&key=AIzaSyD3XJRBhcMBRkdX0rwO3oetB04F-UgxvKQ".format(str(orig_address),str(dest_address))

import json, urllib
orig_address="Seattle,WA"
dest_address="Victoria,BC"
url="https://maps.googleapis.com/maps/api/distancematrix/json?origins={0}&destinations={1}&mode=driving&language=fr-FR&key=AIzaSyD3XJRBhcMBRkdX0rwO3oetB04F-UgxvKQ".format(str(orig_address),str(dest_address))
print(url)
f=urllib.request.urlopen(url)
myfile = f.read()  
print(myfile)

import json, urllib
orig_address="Olympia,WA"
dest_address="Richmond,VA"
url="https://maps.googleapis.com/maps/api/distancematrix/json?origins={0}&destinations={1}&mode=driving&language=fr-FR&key=AIzaSyD3XJRBhcMBRkdX0rwO3oetB04F-UgxvKQ".format(str(orig_address),str(dest_address))
print(url)
f=urllib.request.urlopen(url)
myfile = json.load(f)  
print(myfile)
myfile['rows'][0]["elements"][0]['distance']['value'] #exact m

"""**Web scrap from Wiki to get a list of capital cities in US**"""

#!pip3 install lxml# ! indicates a terminal language not python script
#!pip3 install BeautifulSoup

from bs4 import BeautifulSoup
import urllib.request

web = urllib.request.urlopen("http://en.wikipedia.org/wiki/List_of_capitals_in_the_United_States")
s=web.read()
print(s)

parsed=BeautifulSoup(s,"html.parser")

web_state=urllib.request.urlopen("https://en.wikipedia.org/wiki/List_of_capitals_in_the_United_States")
web_state_html=web_state.read()
parsed_state=BeautifulSoup(web_state_html,"html.parser")
#print(parsed_state)

state_name=['']*50
state_abr=['']*50
state_capital=['']*50

state_info=parsed_state.find_all("tr")
for i in range(50):
  #print(i)
  state=state_info[i+2]
  state_name[i]=state.find_all("td")[0].string
  state_abr[i]=state.find_all("td")[1].string
  #state_capital[i]=state.find_all("td")[3].string
  state_capital[i]=state.find_all("td")[3].a.get("title").replace(" ","")

"""**Use Google API to get the distance between each pair of cities**"""

error_times=0
distance=dict()
for i in range(50):
  for j in range(50):
      orig_address=state_capital[i]
      dest_address=state_capital[j]
      url="https://maps.googleapis.com/maps/api/distancematrix/json?origins={0}&destinations={1}&mode=driving&language=fr-FR&key=AIzaSyD3XJRBhcMBRkdX0rwO3oetB04F-UgxvKQ".format(str(orig_address),str(dest_address))
      #print(url)
      f=urllib.request.urlopen(url)
      myfile = json.load(f) 
      try:
         #print(myfile['rows'][0]["elements"][0]['distance']['value']) #exact m
          distance[(orig_address,dest_address)]=myfile['rows'][0]["elements"][0]['distance']['value']
      except:
        #print("Error",orig_address," ",dest_address)
        error_times=error_times+1
#print(error_times)

for ori_dest in distance:
  print("Start:",ori_dest[0],"  End:",ori_dest[1])
  print(distance[ori_dest])

#len(distance)#1176+1176+50
#len(state_capital) #50

"""**Final Version of GA**"""

import numpy as np
import matplotlib
import numpy as np
import itertools 
import matplotlib.pyplot as plt
import random
import math
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter

np.random.seed(92)

tournament_size=5    
max_generation=10000                            # this says how many generation we should simulate. 
mutation_frac=0.3                                
mutation_scale=0.1 
population_size=25   


start_city=state_capital[0]#fix the start and find the later route.
city_range=state_capital[1:10]+state_capital[11:]#delete Honolulu and start
city_num=48#ignore the start point


population_route=np.zeros((population_size,city_number)).astype(int)
for i in range(population_size):
   population_route[i,]=np.random.permutation(range(0,city_num)).astype(int)#store the route except the start_point, city_index 1:48    

                             # we use tournment selection to select who would reproduce. tournament_size is the size of the tournament.                  
#select_potantial_parents=np.zeros((tournament_size,2))   # this is where all potential parents selected to attend the tournament are hold.
                             # this is the standard deviation of the noise that is added to 
                                                   #mutation_frac of the new generation that are randomly chosen to be mutated.

"""**Route Distance Calculation: the distance of a loop**"""

#define route distance including start point
def route_distance(a,start_city=state_capital[0]):
  sum=distance[(start_city,city_range[a[0]])]
  for i in range(len(a)-1):  
    sum=sum+distance[(city_range[a[i]],city_range[a[i+1]])]  
  sum=sum+distance[(city_range[a[i]],start_city)]
  return(sum)

"""**Crossover function**"""

def crossover(a,b):
  length=random.randint(10,city_number-10)
  start=random.randint(0,city_number-length)#0-city_num
  end=start+length-1
  #print(start)
  #print(end)
  child=np.zeros(city_number).astype(int)
  child[start:(end+1)]=a[start:(end+1)]
  #print(a[start:(end+1)])
  missing_value=[b[i] for i in range(0,city_number) if b[i] not in child[start:(end+1)]]
  #print(missing_value)
  missing_index=[ _ for _ in range(0,city_number) if _<start or _>end]#missing index
  child[missing_index]=np.asarray(missing_value)
  #print(child)
  return(child)

"""**mutation function**"""

#print(a)
#print(b)
mutation_scale=0.2# fraction of swaps
mutation_frac=0.3# fraction of population need to be mutated

def mutation(population_route):
   #num_pop=int(population_size*mutation_frac)
   num_pop=5
   #print(num_pop)
   #num_swap=int(city_number*mutation_scale)
   num_swap=2
   which_pop=random.sample(range(0,population_size),num_pop)
   for i in which_pop:
      #print(i)
      which_swap=np.asarray(random.sample(range(0,city_number),num_swap*2)).reshape(num_swap,2)# no replacement
      #print(which_swap)
      #print(sum(population_list[i]))
      #print(population_list[i])
      (population_route[i,which_swap[:,0]],population_route[i,which_swap[0:,1]])=(population_route[i,which_swap[:,1]],population_route[i,which_swap[0:,0]])
      #print(population_list[i])
      #print(sum(population_list[i]))
   return(population_route)

index=np.zeros(tournament_size).astype(int)
select_population_distance=np.zeros(tournament_size)
new_population=np.zeros((population_size,city_number)).astype(int)
temp_pop_distance=np.zeros(population_size)

max_dist=np.zeros(max_generation)
min_dist=np.zeros(max_generation)


for iter in range(0,max_generation):
  print(iter)
#if True:
  for t in range(0,population_size):
    #print(t)
  #if True:
   # j=1
  #if True:
    select_index=np.random.choice(range(0,population_size), size=tournament_size, replace=False).astype(int)
    #print(select_index)
    select_potantial_parents=list(population_route[i] for i in select_index)
    #print(select_potantial_parents)
    for j in range(0,tournament_size):
       #print(j)
       k=select_index[j]
       #print(k)
       #print(population_route_list[k])
       select_population_distance[j]=route_distance(population_route[k])
    #print(select_population_distance)
    #find potential parent
    parent_1=population_route[select_index[np.argmin(select_population_distance)]]
    #print(parent_1)
    
    
    select_index=np.random.choice(range(0,population_size), size=tournament_size, replace=False).astype(int)
    #print(select_index)
    select_potantial_parents=list(population_route[i] for i in select_index)
    #print(select_potantial_parents)
    for j in range(0,tournament_size):
       #print(j)
       k=select_index[j]
       #print(k)
       #print(population_route[k])
       select_population_distance[j]=route_distance(population_route[k])
    #print(select_population_distance)
    #find potential parent
    parent_2=population_route[select_index[np.argmin(select_population_distance)]]
    #print(parent_2)
    
    new_population[t,]=crossover(parent_1,parent_2)
   
    #print(new_population[j,])
    #print(sum(new_population[j,]))
    
  population_route=mutation(new_population)
  for i in range(0,population_size):
    temp_pop_distance[i]=route_distance(population_route[i,])
  max_dist[iter]=np.max(temp_pop_distance)
  min_dist[iter]=np.min(temp_pop_distance)

import matplotlib.pyplot as plt
plt.plot(min_dist,"r--")
plt.plot(max_dist,"b--")
np.min(min_dist)
min_dist[-100:]
population_route[np.argmin(temp_pop_distance)]
np.min(temp_pop_distance)
#city_range[population_route[np.argmin(temp_pop_distance)]]
#final_path=list(start)

final_path=list()
final_path.append(start_city)
#final_path.append(city_range[1])
for i in range(len(population_route[np.argmin(temp_pop_distance)])):
   #print(i)
   final_path.append(city_range[population_route[np.argmin(temp_pop_distance)][i]])
final_path.append(start_city)
print(final_path)